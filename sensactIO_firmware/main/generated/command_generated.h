// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMAND_SENSACT_COMM_H_
#define FLATBUFFERS_GENERATED_COMMAND_SENSACT_COMM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "_common_generated.h"

namespace sensact {
namespace comm {

struct tBlindCommand;
struct tBlindCommandBuilder;

struct tSinglePwmCommand;
struct tSinglePwmCommandBuilder;

struct tRgbwPwmCommand;
struct tRgbwPwmCommandBuilder;

struct tOnOffCommand;
struct tOnOffCommandBuilder;

struct tCommand;
struct tCommandBuilder;

enum uCommand : uint8_t {
  uCommand_NONE = 0,
  uCommand_tBlindCommand = 1,
  uCommand_tSinglePwmCommand = 2,
  uCommand_tOnOffCommand = 3,
  uCommand_tRgbwPwmCommand = 4,
  uCommand_MIN = uCommand_NONE,
  uCommand_MAX = uCommand_tRgbwPwmCommand
};

inline const uCommand (&EnumValuesuCommand())[5] {
  static const uCommand values[] = {
    uCommand_NONE,
    uCommand_tBlindCommand,
    uCommand_tSinglePwmCommand,
    uCommand_tOnOffCommand,
    uCommand_tRgbwPwmCommand
  };
  return values;
}

inline const char * const *EnumNamesuCommand() {
  static const char * const names[6] = {
    "NONE",
    "tBlindCommand",
    "tSinglePwmCommand",
    "tOnOffCommand",
    "tRgbwPwmCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameuCommand(uCommand e) {
  if (flatbuffers::IsOutRange(e, uCommand_NONE, uCommand_tRgbwPwmCommand)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesuCommand()[index];
}

template<typename T> struct uCommandTraits {
  static const uCommand enum_value = uCommand_NONE;
};

template<> struct uCommandTraits<sensact::comm::tBlindCommand> {
  static const uCommand enum_value = uCommand_tBlindCommand;
};

template<> struct uCommandTraits<sensact::comm::tSinglePwmCommand> {
  static const uCommand enum_value = uCommand_tSinglePwmCommand;
};

template<> struct uCommandTraits<sensact::comm::tOnOffCommand> {
  static const uCommand enum_value = uCommand_tOnOffCommand;
};

template<> struct uCommandTraits<sensact::comm::tRgbwPwmCommand> {
  static const uCommand enum_value = uCommand_tRgbwPwmCommand;
};

bool VerifyuCommand(flatbuffers::Verifier &verifier, const void *obj, uCommand type);
bool VerifyuCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct tBlindCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tBlindCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4
  };
  sensact::comm::eBlindCommand cmd() const {
    return static_cast<sensact::comm::eBlindCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD, 1) &&
           verifier.EndTable();
  }
};

struct tBlindCommandBuilder {
  typedef tBlindCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eBlindCommand cmd) {
    fbb_.AddElement<int8_t>(tBlindCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  explicit tBlindCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<tBlindCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tBlindCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tBlindCommand> CreatetBlindCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eBlindCommand cmd = sensact::comm::eBlindCommand_STOP) {
  tBlindCommandBuilder builder_(_fbb);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tSinglePwmCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tSinglePwmCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_INTENSITY_0_1 = 6
  };
  sensact::comm::eSinglePwmCommand cmd() const {
    return static_cast<sensact::comm::eSinglePwmCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  float intensity_0_1() const {
    return GetField<float>(VT_INTENSITY_0_1, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD, 1) &&
           VerifyField<float>(verifier, VT_INTENSITY_0_1, 4) &&
           verifier.EndTable();
  }
};

struct tSinglePwmCommandBuilder {
  typedef tSinglePwmCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eSinglePwmCommand cmd) {
    fbb_.AddElement<int8_t>(tSinglePwmCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_intensity_0_1(float intensity_0_1) {
    fbb_.AddElement<float>(tSinglePwmCommand::VT_INTENSITY_0_1, intensity_0_1, 0.0f);
  }
  explicit tSinglePwmCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<tSinglePwmCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tSinglePwmCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tSinglePwmCommand> CreatetSinglePwmCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eSinglePwmCommand cmd = sensact::comm::eSinglePwmCommand_TOGGLE,
    float intensity_0_1 = 0.0f) {
  tSinglePwmCommandBuilder builder_(_fbb);
  builder_.add_intensity_0_1(intensity_0_1);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tRgbwPwmCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tRgbwPwmCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_PAYLOAD = 6
  };
  sensact::comm::eRgbwPwmCommand cmd() const {
    return static_cast<sensact::comm::eRgbwPwmCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  float payload() const {
    return GetField<float>(VT_PAYLOAD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD, 1) &&
           VerifyField<float>(verifier, VT_PAYLOAD, 4) &&
           verifier.EndTable();
  }
};

struct tRgbwPwmCommandBuilder {
  typedef tRgbwPwmCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eRgbwPwmCommand cmd) {
    fbb_.AddElement<int8_t>(tRgbwPwmCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_payload(float payload) {
    fbb_.AddElement<float>(tRgbwPwmCommand::VT_PAYLOAD, payload, 0.0f);
  }
  explicit tRgbwPwmCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<tRgbwPwmCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tRgbwPwmCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tRgbwPwmCommand> CreatetRgbwPwmCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eRgbwPwmCommand cmd = sensact::comm::eRgbwPwmCommand_TOGGLE,
    float payload = 0.0f) {
  tRgbwPwmCommandBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tOnOffCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tOnOffCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_MSECS = 6
  };
  sensact::comm::eOnOffCommand cmd() const {
    return static_cast<sensact::comm::eOnOffCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  uint32_t msecs() const {
    return GetField<uint32_t>(VT_MSECS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD, 1) &&
           VerifyField<uint32_t>(verifier, VT_MSECS, 4) &&
           verifier.EndTable();
  }
};

struct tOnOffCommandBuilder {
  typedef tOnOffCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eOnOffCommand cmd) {
    fbb_.AddElement<int8_t>(tOnOffCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_msecs(uint32_t msecs) {
    fbb_.AddElement<uint32_t>(tOnOffCommand::VT_MSECS, msecs, 0);
  }
  explicit tOnOffCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<tOnOffCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tOnOffCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tOnOffCommand> CreatetOnOffCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eOnOffCommand cmd = sensact::comm::eOnOffCommand_ON,
    uint32_t msecs = 0) {
  tOnOffCommandBuilder builder_(_fbb);
  builder_.add_msecs(msecs);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLICATION_ID = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8
  };
  uint32_t application_id() const {
    return GetField<uint32_t>(VT_APPLICATION_ID, 0);
  }
  sensact::comm::uCommand command_type() const {
    return static_cast<sensact::comm::uCommand>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const sensact::comm::tBlindCommand *command_as_tBlindCommand() const {
    return command_type() == sensact::comm::uCommand_tBlindCommand ? static_cast<const sensact::comm::tBlindCommand *>(command()) : nullptr;
  }
  const sensact::comm::tSinglePwmCommand *command_as_tSinglePwmCommand() const {
    return command_type() == sensact::comm::uCommand_tSinglePwmCommand ? static_cast<const sensact::comm::tSinglePwmCommand *>(command()) : nullptr;
  }
  const sensact::comm::tOnOffCommand *command_as_tOnOffCommand() const {
    return command_type() == sensact::comm::uCommand_tOnOffCommand ? static_cast<const sensact::comm::tOnOffCommand *>(command()) : nullptr;
  }
  const sensact::comm::tRgbwPwmCommand *command_as_tRgbwPwmCommand() const {
    return command_type() == sensact::comm::uCommand_tRgbwPwmCommand ? static_cast<const sensact::comm::tRgbwPwmCommand *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_APPLICATION_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyuCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sensact::comm::tBlindCommand *tCommand::command_as<sensact::comm::tBlindCommand>() const {
  return command_as_tBlindCommand();
}

template<> inline const sensact::comm::tSinglePwmCommand *tCommand::command_as<sensact::comm::tSinglePwmCommand>() const {
  return command_as_tSinglePwmCommand();
}

template<> inline const sensact::comm::tOnOffCommand *tCommand::command_as<sensact::comm::tOnOffCommand>() const {
  return command_as_tOnOffCommand();
}

template<> inline const sensact::comm::tRgbwPwmCommand *tCommand::command_as<sensact::comm::tRgbwPwmCommand>() const {
  return command_as_tRgbwPwmCommand();
}

struct tCommandBuilder {
  typedef tCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_application_id(uint32_t application_id) {
    fbb_.AddElement<uint32_t>(tCommand::VT_APPLICATION_ID, application_id, 0);
  }
  void add_command_type(sensact::comm::uCommand command_type) {
    fbb_.AddElement<uint8_t>(tCommand::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(tCommand::VT_COMMAND, command);
  }
  explicit tCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<tCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tCommand> CreatetCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t application_id = 0,
    sensact::comm::uCommand command_type = sensact::comm::uCommand_NONE,
    flatbuffers::Offset<void> command = 0) {
  tCommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_application_id(application_id);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline bool VerifyuCommand(flatbuffers::Verifier &verifier, const void *obj, uCommand type) {
  switch (type) {
    case uCommand_NONE: {
      return true;
    }
    case uCommand_tBlindCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tBlindCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uCommand_tSinglePwmCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tSinglePwmCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uCommand_tOnOffCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tOnOffCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uCommand_tRgbwPwmCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tRgbwPwmCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyuCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuCommand(
        verifier,  values->Get(i), types->GetEnum<uCommand>(i))) {
      return false;
    }
  }
  return true;
}

inline const sensact::comm::tCommand *GettCommand(const void *buf) {
  return flatbuffers::GetRoot<sensact::comm::tCommand>(buf);
}

inline const sensact::comm::tCommand *GetSizePrefixedtCommand(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<sensact::comm::tCommand>(buf);
}

inline const char *tCommandIdentifier() {
  return "SCMD";
}

inline bool tCommandBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, tCommandIdentifier());
}

inline bool SizePrefixedtCommandBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, tCommandIdentifier(), true);
}

inline bool VerifytCommandBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sensact::comm::tCommand>(tCommandIdentifier());
}

inline bool VerifySizePrefixedtCommandBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sensact::comm::tCommand>(tCommandIdentifier());
}

inline void FinishtCommandBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sensact::comm::tCommand> root) {
  fbb.Finish(root, tCommandIdentifier());
}

inline void FinishSizePrefixedtCommandBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<sensact::comm::tCommand> root) {
  fbb.FinishSizePrefixed(root, tCommandIdentifier());
}

}  // namespace comm
}  // namespace sensact

#endif  // FLATBUFFERS_GENERATED_COMMAND_SENSACT_COMM_H_
