// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATE_SENSACT_COMM_H_
#define FLATBUFFERS_GENERATED_STATE_SENSACT_COMM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "_common_generated.h"

namespace sensact {
namespace comm {

struct tBlindState;
struct tBlindStateBuilder;

struct tSinglePwmState;
struct tSinglePwmStateBuilder;

struct tRgbwPwmState;
struct tRgbwPwmStateBuilder;

struct tOnOffState;
struct tOnOffStateBuilder;

struct tStateWrapper;
struct tStateWrapperBuilder;

struct tState;
struct tStateBuilder;

enum uState : uint8_t {
  uState_NONE = 0,
  uState_tBlindState = 1,
  uState_tSinglePwmState = 2,
  uState_tOnOffState = 3,
  uState_tRgbwPwmState = 4,
  uState_MIN = uState_NONE,
  uState_MAX = uState_tRgbwPwmState
};

inline const uState (&EnumValuesuState())[5] {
  static const uState values[] = {
    uState_NONE,
    uState_tBlindState,
    uState_tSinglePwmState,
    uState_tOnOffState,
    uState_tRgbwPwmState
  };
  return values;
}

inline const char * const *EnumNamesuState() {
  static const char * const names[6] = {
    "NONE",
    "tBlindState",
    "tSinglePwmState",
    "tOnOffState",
    "tRgbwPwmState",
    nullptr
  };
  return names;
}

inline const char *EnumNameuState(uState e) {
  if (::flatbuffers::IsOutRange(e, uState_NONE, uState_tRgbwPwmState)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesuState()[index];
}

template<typename T> struct uStateTraits {
  static const uState enum_value = uState_NONE;
};

template<> struct uStateTraits<sensact::comm::tBlindState> {
  static const uState enum_value = uState_tBlindState;
};

template<> struct uStateTraits<sensact::comm::tSinglePwmState> {
  static const uState enum_value = uState_tSinglePwmState;
};

template<> struct uStateTraits<sensact::comm::tOnOffState> {
  static const uState enum_value = uState_tOnOffState;
};

template<> struct uStateTraits<sensact::comm::tRgbwPwmState> {
  static const uState enum_value = uState_tRgbwPwmState;
};

bool VerifyuState(::flatbuffers::Verifier &verifier, const void *obj, uState type);
bool VerifyuStateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct tBlindState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tBlindStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_STATE = 6
  };
  uint16_t position() const {
    return GetField<uint16_t>(VT_POSITION, 0);
  }
  sensact::comm::eBlindState state() const {
    return static_cast<sensact::comm::eBlindState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_POSITION, 2) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
};

struct tBlindStateBuilder {
  typedef tBlindState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(uint16_t position) {
    fbb_.AddElement<uint16_t>(tBlindState::VT_POSITION, position, 0);
  }
  void add_state(sensact::comm::eBlindState state) {
    fbb_.AddElement<int8_t>(tBlindState::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit tBlindStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tBlindState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tBlindState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tBlindState> CreatetBlindState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t position = 0,
    sensact::comm::eBlindState state = sensact::comm::eBlindState_STOP) {
  tBlindStateBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_state(state);
  return builder_.Finish();
}

struct tSinglePwmState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tSinglePwmStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTENSITY_0_1 = 4,
    VT_ON = 6
  };
  float intensity_0_1() const {
    return GetField<float>(VT_INTENSITY_0_1, 0.0f);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_INTENSITY_0_1, 4) &&
           VerifyField<uint8_t>(verifier, VT_ON, 1) &&
           verifier.EndTable();
  }
};

struct tSinglePwmStateBuilder {
  typedef tSinglePwmState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_intensity_0_1(float intensity_0_1) {
    fbb_.AddElement<float>(tSinglePwmState::VT_INTENSITY_0_1, intensity_0_1, 0.0f);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(tSinglePwmState::VT_ON, static_cast<uint8_t>(on), 0);
  }
  explicit tSinglePwmStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tSinglePwmState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tSinglePwmState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tSinglePwmState> CreatetSinglePwmState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float intensity_0_1 = 0.0f,
    bool on = false) {
  tSinglePwmStateBuilder builder_(_fbb);
  builder_.add_intensity_0_1(intensity_0_1);
  builder_.add_on(on);
  return builder_.Finish();
}

struct tRgbwPwmState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tRgbwPwmStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_R = 4,
    VT_G = 6,
    VT_B = 8,
    VT_WW = 10,
    VT_CW = 12,
    VT_ON = 14
  };
  uint8_t r() const {
    return GetField<uint8_t>(VT_R, 0);
  }
  uint8_t g() const {
    return GetField<uint8_t>(VT_G, 0);
  }
  uint8_t b() const {
    return GetField<uint8_t>(VT_B, 0);
  }
  float ww() const {
    return GetField<float>(VT_WW, 0.0f);
  }
  float cw() const {
    return GetField<float>(VT_CW, 0.0f);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_R, 1) &&
           VerifyField<uint8_t>(verifier, VT_G, 1) &&
           VerifyField<uint8_t>(verifier, VT_B, 1) &&
           VerifyField<float>(verifier, VT_WW, 4) &&
           VerifyField<float>(verifier, VT_CW, 4) &&
           VerifyField<uint8_t>(verifier, VT_ON, 1) &&
           verifier.EndTable();
  }
};

struct tRgbwPwmStateBuilder {
  typedef tRgbwPwmState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_r(uint8_t r) {
    fbb_.AddElement<uint8_t>(tRgbwPwmState::VT_R, r, 0);
  }
  void add_g(uint8_t g) {
    fbb_.AddElement<uint8_t>(tRgbwPwmState::VT_G, g, 0);
  }
  void add_b(uint8_t b) {
    fbb_.AddElement<uint8_t>(tRgbwPwmState::VT_B, b, 0);
  }
  void add_ww(float ww) {
    fbb_.AddElement<float>(tRgbwPwmState::VT_WW, ww, 0.0f);
  }
  void add_cw(float cw) {
    fbb_.AddElement<float>(tRgbwPwmState::VT_CW, cw, 0.0f);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(tRgbwPwmState::VT_ON, static_cast<uint8_t>(on), 0);
  }
  explicit tRgbwPwmStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tRgbwPwmState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tRgbwPwmState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tRgbwPwmState> CreatetRgbwPwmState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t r = 0,
    uint8_t g = 0,
    uint8_t b = 0,
    float ww = 0.0f,
    float cw = 0.0f,
    bool on = false) {
  tRgbwPwmStateBuilder builder_(_fbb);
  builder_.add_cw(cw);
  builder_.add_ww(ww);
  builder_.add_on(on);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  return builder_.Finish();
}

struct tOnOffState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tOnOffStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  sensact::comm::eOnOffState state() const {
    return static_cast<sensact::comm::eOnOffState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
};

struct tOnOffStateBuilder {
  typedef tOnOffState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(sensact::comm::eOnOffState state) {
    fbb_.AddElement<int8_t>(tOnOffState::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit tOnOffStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tOnOffState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tOnOffState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tOnOffState> CreatetOnOffState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eOnOffState state = sensact::comm::eOnOffState_MANUAL_OFF) {
  tOnOffStateBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct tStateWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tStateWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLICATION_ID = 4,
    VT_STATE_TYPE = 6,
    VT_STATE = 8
  };
  uint32_t application_id() const {
    return GetField<uint32_t>(VT_APPLICATION_ID, 0);
  }
  sensact::comm::uState state_type() const {
    return static_cast<sensact::comm::uState>(GetField<uint8_t>(VT_STATE_TYPE, 0));
  }
  const void *state() const {
    return GetPointer<const void *>(VT_STATE);
  }
  template<typename T> const T *state_as() const;
  const sensact::comm::tBlindState *state_as_tBlindState() const {
    return state_type() == sensact::comm::uState_tBlindState ? static_cast<const sensact::comm::tBlindState *>(state()) : nullptr;
  }
  const sensact::comm::tSinglePwmState *state_as_tSinglePwmState() const {
    return state_type() == sensact::comm::uState_tSinglePwmState ? static_cast<const sensact::comm::tSinglePwmState *>(state()) : nullptr;
  }
  const sensact::comm::tOnOffState *state_as_tOnOffState() const {
    return state_type() == sensact::comm::uState_tOnOffState ? static_cast<const sensact::comm::tOnOffState *>(state()) : nullptr;
  }
  const sensact::comm::tRgbwPwmState *state_as_tRgbwPwmState() const {
    return state_type() == sensact::comm::uState_tRgbwPwmState ? static_cast<const sensact::comm::tRgbwPwmState *>(state()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_APPLICATION_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_STATE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STATE) &&
           VerifyuState(verifier, state(), state_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sensact::comm::tBlindState *tStateWrapper::state_as<sensact::comm::tBlindState>() const {
  return state_as_tBlindState();
}

template<> inline const sensact::comm::tSinglePwmState *tStateWrapper::state_as<sensact::comm::tSinglePwmState>() const {
  return state_as_tSinglePwmState();
}

template<> inline const sensact::comm::tOnOffState *tStateWrapper::state_as<sensact::comm::tOnOffState>() const {
  return state_as_tOnOffState();
}

template<> inline const sensact::comm::tRgbwPwmState *tStateWrapper::state_as<sensact::comm::tRgbwPwmState>() const {
  return state_as_tRgbwPwmState();
}

struct tStateWrapperBuilder {
  typedef tStateWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_application_id(uint32_t application_id) {
    fbb_.AddElement<uint32_t>(tStateWrapper::VT_APPLICATION_ID, application_id, 0);
  }
  void add_state_type(sensact::comm::uState state_type) {
    fbb_.AddElement<uint8_t>(tStateWrapper::VT_STATE_TYPE, static_cast<uint8_t>(state_type), 0);
  }
  void add_state(::flatbuffers::Offset<void> state) {
    fbb_.AddOffset(tStateWrapper::VT_STATE, state);
  }
  explicit tStateWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tStateWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tStateWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tStateWrapper> CreatetStateWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t application_id = 0,
    sensact::comm::uState state_type = sensact::comm::uState_NONE,
    ::flatbuffers::Offset<void> state = 0) {
  tStateWrapperBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_application_id(application_id);
  builder_.add_state_type(state_type);
  return builder_.Finish();
}

struct tState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_STATES = 6
  };
  uint32_t timestamp() const {
    return GetField<uint32_t>(VT_TIMESTAMP, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<sensact::comm::tStateWrapper>> *states() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<sensact::comm::tStateWrapper>> *>(VT_STATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TIMESTAMP, 4) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
};

struct tStateBuilder {
  typedef tState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint32_t timestamp) {
    fbb_.AddElement<uint32_t>(tState::VT_TIMESTAMP, timestamp, 0);
  }
  void add_states(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensact::comm::tStateWrapper>>> states) {
    fbb_.AddOffset(tState::VT_STATES, states);
  }
  explicit tStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tState> CreatetState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensact::comm::tStateWrapper>>> states = 0) {
  tStateBuilder builder_(_fbb);
  builder_.add_states(states);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<tState> CreatetStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t timestamp = 0,
    const std::vector<::flatbuffers::Offset<sensact::comm::tStateWrapper>> *states = nullptr) {
  auto states__ = states ? _fbb.CreateVector<::flatbuffers::Offset<sensact::comm::tStateWrapper>>(*states) : 0;
  return sensact::comm::CreatetState(
      _fbb,
      timestamp,
      states__);
}

inline bool VerifyuState(::flatbuffers::Verifier &verifier, const void *obj, uState type) {
  switch (type) {
    case uState_NONE: {
      return true;
    }
    case uState_tBlindState: {
      auto ptr = reinterpret_cast<const sensact::comm::tBlindState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uState_tSinglePwmState: {
      auto ptr = reinterpret_cast<const sensact::comm::tSinglePwmState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uState_tOnOffState: {
      auto ptr = reinterpret_cast<const sensact::comm::tOnOffState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uState_tRgbwPwmState: {
      auto ptr = reinterpret_cast<const sensact::comm::tRgbwPwmState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyuStateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuState(
        verifier,  values->Get(i), types->GetEnum<uState>(i))) {
      return false;
    }
  }
  return true;
}

inline const sensact::comm::tState *GettState(const void *buf) {
  return ::flatbuffers::GetRoot<sensact::comm::tState>(buf);
}

inline const sensact::comm::tState *GetSizePrefixedtState(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<sensact::comm::tState>(buf);
}

inline const char *tStateIdentifier() {
  return "SSTA";
}

inline bool tStateBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, tStateIdentifier());
}

inline bool SizePrefixedtStateBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, tStateIdentifier(), true);
}

inline bool VerifytStateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<sensact::comm::tState>(tStateIdentifier());
}

inline bool VerifySizePrefixedtStateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<sensact::comm::tState>(tStateIdentifier());
}

inline void FinishtStateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sensact::comm::tState> root) {
  fbb.Finish(root, tStateIdentifier());
}

inline void FinishSizePrefixedtStateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<sensact::comm::tState> root) {
  fbb.FinishSizePrefixed(root, tStateIdentifier());
}

}  // namespace comm
}  // namespace sensact

#endif  // FLATBUFFERS_GENERATED_STATE_SENSACT_COMM_H_
