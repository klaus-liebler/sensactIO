// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_SENSACT_COMM_H_
#define FLATBUFFERS_GENERATED_COMMON_SENSACT_COMM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace sensact {
namespace comm {

enum eRelayInterlockMode : int8_t {
  eRelayInterlockMode_R1_UP__R2_DOWN = 0,
  eRelayInterlockMode_R1_DOWN__R2_UP = 1,
  eRelayInterlockMode_R1_POWER__R2_UP = 2,
  eRelayInterlockMode_R1_POWER__R2_DOWN = 3,
  eRelayInterlockMode_R1_UP__R2_POWER = 4,
  eRelayInterlockMode_R1_DOWN__R2_POWER = 5,
  eRelayInterlockMode_MIN = eRelayInterlockMode_R1_UP__R2_DOWN,
  eRelayInterlockMode_MAX = eRelayInterlockMode_R1_DOWN__R2_POWER
};

inline const eRelayInterlockMode (&EnumValueseRelayInterlockMode())[6] {
  static const eRelayInterlockMode values[] = {
    eRelayInterlockMode_R1_UP__R2_DOWN,
    eRelayInterlockMode_R1_DOWN__R2_UP,
    eRelayInterlockMode_R1_POWER__R2_UP,
    eRelayInterlockMode_R1_POWER__R2_DOWN,
    eRelayInterlockMode_R1_UP__R2_POWER,
    eRelayInterlockMode_R1_DOWN__R2_POWER
  };
  return values;
}

inline const char * const *EnumNameseRelayInterlockMode() {
  static const char * const names[7] = {
    "R1_UP__R2_DOWN",
    "R1_DOWN__R2_UP",
    "R1_POWER__R2_UP",
    "R1_POWER__R2_DOWN",
    "R1_UP__R2_POWER",
    "R1_DOWN__R2_POWER",
    nullptr
  };
  return names;
}

inline const char *EnumNameeRelayInterlockMode(eRelayInterlockMode e) {
  if (flatbuffers::IsOutRange(e, eRelayInterlockMode_R1_UP__R2_DOWN, eRelayInterlockMode_R1_DOWN__R2_POWER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseRelayInterlockMode()[index];
}

enum eBlindState : int8_t {
  eBlindState_STOP = 0,
  eBlindState_UP = 1,
  eBlindState_DOWN = 2,
  eBlindState_PREPARE = 3,
  eBlindState_MIN = eBlindState_STOP,
  eBlindState_MAX = eBlindState_PREPARE
};

inline const eBlindState (&EnumValueseBlindState())[4] {
  static const eBlindState values[] = {
    eBlindState_STOP,
    eBlindState_UP,
    eBlindState_DOWN,
    eBlindState_PREPARE
  };
  return values;
}

inline const char * const *EnumNameseBlindState() {
  static const char * const names[5] = {
    "STOP",
    "UP",
    "DOWN",
    "PREPARE",
    nullptr
  };
  return names;
}

inline const char *EnumNameeBlindState(eBlindState e) {
  if (flatbuffers::IsOutRange(e, eBlindState_STOP, eBlindState_PREPARE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseBlindState()[index];
}

enum eBlindCommand : int8_t {
  eBlindCommand_STOP = 0,
  eBlindCommand_UP = 1,
  eBlindCommand_DOWN = 2,
  eBlindCommand_UP_OR_STOP = 3,
  eBlindCommand_DOWN_OR_STOP = 4,
  eBlindCommand_MIN = eBlindCommand_STOP,
  eBlindCommand_MAX = eBlindCommand_DOWN_OR_STOP
};

inline const eBlindCommand (&EnumValueseBlindCommand())[5] {
  static const eBlindCommand values[] = {
    eBlindCommand_STOP,
    eBlindCommand_UP,
    eBlindCommand_DOWN,
    eBlindCommand_UP_OR_STOP,
    eBlindCommand_DOWN_OR_STOP
  };
  return values;
}

inline const char * const *EnumNameseBlindCommand() {
  static const char * const names[6] = {
    "STOP",
    "UP",
    "DOWN",
    "UP_OR_STOP",
    "DOWN_OR_STOP",
    nullptr
  };
  return names;
}

inline const char *EnumNameeBlindCommand(eBlindCommand e) {
  if (flatbuffers::IsOutRange(e, eBlindCommand_STOP, eBlindCommand_DOWN_OR_STOP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseBlindCommand()[index];
}

enum eSinglePwmCommand : int8_t {
  eSinglePwmCommand_TOGGLE = 0,
  eSinglePwmCommand_ON = 1,
  eSinglePwmCommand_OFF = 2,
  eSinglePwmCommand_CHANGE_INTENSITY = 3,
  eSinglePwmCommand_MIN = eSinglePwmCommand_TOGGLE,
  eSinglePwmCommand_MAX = eSinglePwmCommand_CHANGE_INTENSITY
};

inline const eSinglePwmCommand (&EnumValueseSinglePwmCommand())[4] {
  static const eSinglePwmCommand values[] = {
    eSinglePwmCommand_TOGGLE,
    eSinglePwmCommand_ON,
    eSinglePwmCommand_OFF,
    eSinglePwmCommand_CHANGE_INTENSITY
  };
  return values;
}

inline const char * const *EnumNameseSinglePwmCommand() {
  static const char * const names[5] = {
    "TOGGLE",
    "ON",
    "OFF",
    "CHANGE_INTENSITY",
    nullptr
  };
  return names;
}

inline const char *EnumNameeSinglePwmCommand(eSinglePwmCommand e) {
  if (flatbuffers::IsOutRange(e, eSinglePwmCommand_TOGGLE, eSinglePwmCommand_CHANGE_INTENSITY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseSinglePwmCommand()[index];
}

enum eRgbwPwmCommand : int8_t {
  eRgbwPwmCommand_TOGGLE = 0,
  eRgbwPwmCommand_ON = 1,
  eRgbwPwmCommand_OFF = 2,
  eRgbwPwmCommand_CHANGE_HUE_0_360 = 3,
  eRgbwPwmCommand_CHANGE_SATURATION_0_1 = 4,
  eRgbwPwmCommand_CHANGE_VALUE_0_1 = 5,
  eRgbwPwmCommand_CHANGE_R_0_255 = 6,
  eRgbwPwmCommand_CHANGE_G_0_255 = 7,
  eRgbwPwmCommand_CHANGE_B_0_255 = 8,
  eRgbwPwmCommand_CHANGE_WWCW_BRIGHTNESS_0_1 = 9,
  eRgbwPwmCommand_CHANGE_WWCW_RATIO_0_1 = 10,
  eRgbwPwmCommand_MIN = eRgbwPwmCommand_TOGGLE,
  eRgbwPwmCommand_MAX = eRgbwPwmCommand_CHANGE_WWCW_RATIO_0_1
};

inline const eRgbwPwmCommand (&EnumValueseRgbwPwmCommand())[11] {
  static const eRgbwPwmCommand values[] = {
    eRgbwPwmCommand_TOGGLE,
    eRgbwPwmCommand_ON,
    eRgbwPwmCommand_OFF,
    eRgbwPwmCommand_CHANGE_HUE_0_360,
    eRgbwPwmCommand_CHANGE_SATURATION_0_1,
    eRgbwPwmCommand_CHANGE_VALUE_0_1,
    eRgbwPwmCommand_CHANGE_R_0_255,
    eRgbwPwmCommand_CHANGE_G_0_255,
    eRgbwPwmCommand_CHANGE_B_0_255,
    eRgbwPwmCommand_CHANGE_WWCW_BRIGHTNESS_0_1,
    eRgbwPwmCommand_CHANGE_WWCW_RATIO_0_1
  };
  return values;
}

inline const char * const *EnumNameseRgbwPwmCommand() {
  static const char * const names[12] = {
    "TOGGLE",
    "ON",
    "OFF",
    "CHANGE_HUE_0_360",
    "CHANGE_SATURATION_0_1",
    "CHANGE_VALUE_0_1",
    "CHANGE_R_0_255",
    "CHANGE_G_0_255",
    "CHANGE_B_0_255",
    "CHANGE_WWCW_BRIGHTNESS_0_1",
    "CHANGE_WWCW_RATIO_0_1",
    nullptr
  };
  return names;
}

inline const char *EnumNameeRgbwPwmCommand(eRgbwPwmCommand e) {
  if (flatbuffers::IsOutRange(e, eRgbwPwmCommand_TOGGLE, eRgbwPwmCommand_CHANGE_WWCW_RATIO_0_1)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseRgbwPwmCommand()[index];
}

enum eOnOffCommand : int8_t {
  eOnOffCommand_ON = 0,
  eOnOffCommand_AUTO = 1,
  eOnOffCommand_OFF = 2,
  eOnOffCommand_TRIGGER = 3,
  eOnOffCommand_TRIGGER_MSECS = 4,
  eOnOffCommand_MIN = eOnOffCommand_ON,
  eOnOffCommand_MAX = eOnOffCommand_TRIGGER_MSECS
};

inline const eOnOffCommand (&EnumValueseOnOffCommand())[5] {
  static const eOnOffCommand values[] = {
    eOnOffCommand_ON,
    eOnOffCommand_AUTO,
    eOnOffCommand_OFF,
    eOnOffCommand_TRIGGER,
    eOnOffCommand_TRIGGER_MSECS
  };
  return values;
}

inline const char * const *EnumNameseOnOffCommand() {
  static const char * const names[6] = {
    "ON",
    "AUTO",
    "OFF",
    "TRIGGER",
    "TRIGGER_MSECS",
    nullptr
  };
  return names;
}

inline const char *EnumNameeOnOffCommand(eOnOffCommand e) {
  if (flatbuffers::IsOutRange(e, eOnOffCommand_ON, eOnOffCommand_TRIGGER_MSECS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseOnOffCommand()[index];
}

enum eOnOffState : int8_t {
  eOnOffState_MANUAL_OFF = 0,
  eOnOffState_MANUAL_ON = 1,
  eOnOffState_AUTO_OFF = 2,
  eOnOffState_AUTO_ON = 3,
  eOnOffState_MIN = eOnOffState_MANUAL_OFF,
  eOnOffState_MAX = eOnOffState_AUTO_ON
};

inline const eOnOffState (&EnumValueseOnOffState())[4] {
  static const eOnOffState values[] = {
    eOnOffState_MANUAL_OFF,
    eOnOffState_MANUAL_ON,
    eOnOffState_AUTO_OFF,
    eOnOffState_AUTO_ON
  };
  return values;
}

inline const char * const *EnumNameseOnOffState() {
  static const char * const names[5] = {
    "MANUAL_OFF",
    "MANUAL_ON",
    "AUTO_OFF",
    "AUTO_ON",
    nullptr
  };
  return names;
}

inline const char *EnumNameeOnOffState(eOnOffState e) {
  if (flatbuffers::IsOutRange(e, eOnOffState_MANUAL_OFF, eOnOffState_AUTO_ON)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseOnOffState()[index];
}

}  // namespace comm
}  // namespace sensact

#endif  // FLATBUFFERS_GENERATED_COMMON_SENSACT_COMM_H_
